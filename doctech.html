
<head>
	<meta charset="utf-8" />
	<title>DOCUMENATTION TECHNIQUE</title>
	<meta name="language" content="fr">
	<meta name="description" content="DESCRIPTION DE LA PAGE.">
	<meta name="keywords" content="keyword1, keyword2, keyword3" lang="fr">
	<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
	<link rel="stylesheet" href="styles/style.css">
	<link rel="stylesheet" href="styles/doc.css">
	<script src="https://kit.fontawesome.com/a076d05399.js"></script>	
</head>
<body>
	<header>
		<div id="up-page">
			<div class="header-buttons">
				<div id="logo">
					<a href="accueil.html"><img style="height: 3vw" src="https://static1.squarespace.com/static/59f0de346957da078de340e3/t/5be9824d032be4540ec984d1/1542029902989/CA_PRIMARY_LOGO.png?format=1500w"></a>
				</div>
				<div id="navbar">
					<a href="accueil.html">ACCUEIL</a>
					<a href="doc.html">DOCUMENTATION</a>
					<a href="doctech.html">DOC TECHNIQUE</a>
				</div>
				<div class="dropdown">
					<button onclick="myFunction(event)" class="dropbtn">
						MENU
						<i class="fas fa-bars"></i>
					</button>
					<div id="myDropdown" class="dropdown-content">
						<a href="accueil.html">Accueil</a>
						<a href="doc.html">Documentation</a>
						<a href="doctech.html">Doc technique</a>
					</div>
				</div>
			</div>
		</div>
		<div>
			<img style="width: 100%" src="https://d32ogoqmya1dw8.cloudfront.net/images/integrate/teaching_materials/global_energy/earths_thermostat_banner_3.jpg">
		</div>
	</header>

	<div class="category">
		<button>DOC TECHNIQUE</button>
	</div>
	<div style="margin-left: 20px; margin-right: 20px;">
		<div>
			<p>
				<h2>FILTRES</h2><br>
				Lorsque l'aplication doit afficher des informations à l'utilisateur, il se peut que certains filtres doient être mis en place pour éviter d'afficher des informations inutiles, mais aussi empêcher l'utilisateur d'accéder à des informations qu'il n'a pas le droit de voir en temps normal. De plus, l'utilisateur souhaite surement lui-même trouver plus facilement un certain contenu.<br>
				<br>
				Voici donc un exemple de filtre : celui-ci sert à afficher les projets de l'architecte référrént à celui-ci, avec potentiellement des filtres supplémentaires selon son bon vouloir.
				<br>
			</p>
			<pre><code>
public String architectProjectFilter(JTextField userName, JTextField userFirstName, JTextField projectName) {
	String request = "SELECT A.architect_id, U.user_firstname, U.user_name, P.project_name, A.architect_assigned_datetime\n" +
            "FROM architects AS A, users AS U, projects AS P " +
            "WHERE U.user_id = A.architect_id AND P.project_id = A.architect_project_id";
    if (userFirstName.getText().length() >= 3)
        request = request + " AND U.user_firstname LIKE '" + userFirstName.getText() + "%'";
    if (userName.getText().length() >= 3)
        request = request + " AND U.user_name LIKE '" + userName.getText() + "%'";
    if (projectName.getText().length() >= 3)
        request = request + " AND P.project_name LIKE '" + projectName.getText() + "%'";
    System.out.println(request);
	
    return request;
}
			</code></pre>
			<p>
				<pre><code>
public String architectProjectFilter(JTextField userName, JTextField userFirstName, JTextField projectName) {
				</code></pre>
				<br>

				Il s'agit de a fonction appellée avant de faire la requête, étant donné que le filtre retourne une requête SQL sous forme de String.<br><br>

				<pre><code>
String request = "SELECT A.architect_id, U.user_firstname, U.user_name, P.project_name, A.architect_assigned_datetime\n" +
"FROM architects AS A, users AS U, projects AS P " +
"WHERE U.user_id = A.architect_id AND P.project_id = A.architect_project_id";
			    </code></pre>

			    Voici donc le filtre par défaut: il s'agit donc du filtre de permission: <br>
			    <li>Dans SELECT</li> tout ce qui est séparé par des "," sont les collones des tables de la base de donnée qui seront affichées. Leur syntaxe est la suivante : [Alias].[Column].<br>
			    L'alias est un identifiant pour alléger le code lorsque plusieurs tables sont utilisées en même temps et donc le rendre plus lisible.

			    <li>Dans FROM</li>, ce qui suit sont les tables utilisées pour l'affichage de leur(s) colonne(s). C'est ici que l'on leur attribut l'alias: [Table] AS [Alias].

			    <li>Dans WHERE</li>, il s'agit de conditions à remplir: seules les résultats de ce premier filtre de permission qui rempliront tous les critères seront acceptés. le filtrage n'est pas encore effectué puisqu'il s'agit juste de remplir un String.<br>
			    Dans cet exemple, nous verifions pour chaque ligne que : le projet est bien supervisé par l'architecte et que l'utilisateur connecté est bien l'architecte en question.<br>
			    <br>

			    Maintenant que le filtre de permission est terminé, il reste à appliquer les filtres supplémentaires si l'utilisateur le désire : tous se basent sur le même principe.<br>

			    <pre><code>
if (userFirstName.getText().length() >= 3)
	request = request + " AND U.user_firstname LIKE '" + userFirstName.getText() + "%'";
			    </code></pre>

			    <li>Dans le IF</li>, nbous vérifions que le champs de texte que l'utilisateur a rempli précédemment contienne au moins 3 caractères: sinon, le filtre n'a pas lieu d'être et nous passons à la prochaine vérification OU au return.

			    <li>Si la condition est VRAIE</li>, alors nous ajoutons à notre String une condition "AND" supplémentaire.<br>
			    La condition supplémenaire ci-dessus vérifie que le prénom de l'utilisateur de la table (et non de l'appli) commence bien par le texte entré dans le champs de texte userFirstName, le % indiquant que la suite du texte n'est pas filtrée.<br>
			    Nous vérifions le tetxe avec LIKE plutôt qu'un "=" afin de pouvoir vérifier une ressemblance et non si le texte est parfaitement égal.<br><br>

			    Le même principe s'applique ensuite pour le nom de famille de l'utilisateur ainsi que le nom du projet. une fois tout cela effectué, le String est retourné et la requête aura lieu par la suite.
			</p>
		</div>
		<div>
			<p>
				<h2>AFFICHAGE COMPORTEMENT</h2><br>
				Afin d'être utilisable par le plus grand nombre, l'application s'affiche par le biais d'une interface graphique. L'affichage dépend des paramères de l'utilisateur, par exemple son rôle ou ses actions.<br>
				<br>
				Voici donc un exemple de basculement entre affichage et comportement : 
				<br>
			</p>
			<p>
				<pre><code>
public class Display implements ActionListener {
    private UpdateProfile updateProfile = new UpdateProfile();
    private EditableTable editableTable = new EditableTable();
	
    private JFrame window = new JFrame();
    private JMenu accessMenu = new JMenu("Se connecter / S'enregistrer");
    private JMenuBar cho = new JMenuBar();
    private JMenuItem connexion = new JMenuItem("Se connecter");
    private JMenuItem registration = new JMenuItem("S'inscrire");
    private JButton logIn = new JButton("Connexion");
    private JButton signUp = new JButton("Inscription");
    private JPanel panel = new JPanel();

    private Box l1 = Box.createHorizontalBox();
    private Box l2 = Box.createHorizontalBox();
    private Box l3 = Box.createHorizontalBox();
    private Box l4 = Box.createHorizontalBox();
    private Box l5 = Box.createHorizontalBox();
    private Box c1 = Box.createVerticalBox();
    private JButton disconnect = new JButton("Disconnect");
    private JTextField userMailJTF = new JTextField(10);
    private JPasswordField passWord = new JPasswordField(10);
    private JPasswordField passWordConfirm = new JPasswordField(10);

    private Connection connection;

    /**
     * Initialize the connection to the database, call for displays after
     * @throws SQLException
     */
    protected void setConnection() throws SQLException {
        connection = DriverManager.getConnection("jdbc:mysql://localhost:8889/bdd_ca_design",
                "anthony", "Atelier2");
        setWindow();
    }
	
    JButton leave = new JButton("EXIT");
    /**
     * Displays the main window (Connection / logIn)
     */
    private void setWindow() {
        //*** SET GENERALS INFO OF THE WINDOW ***
        window.setTitle("CA DESIGN - HOME");
        window.setSize(1200, 1000);
        window.setLocationRelativeTo(null);
        window.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        window.setLayout(new FlowLayout());
        //***************************************

        resetWindow();
        accessMenu.add(connexion);
        accessMenu.add(registration);
        connexion.addActionListener(this);
        registration.addActionListener(this);
        cho.add(accessMenu);
        l1.add(cho);
        l2.add(leave);
        c1.add(l1);
        c1.add(l2);
        window.add(c1);
        window.getContentPane().add(panel);
        window.setVisible(true);
		
        leave.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                window.dispose();
            }
        });
    }
    etc...
				</code></pre>

				<br>
				Ici donc, un exemple simple et direct. La fenêtre s'affiche avec ses paramètres comme la taille de celle ci, son nom, ainsi que son contenu comme des boutons, des menus déroulants... etc.<br>
				A ce stade, tout le code concerne l'affichage en mode tiroir: on ajoute les éléments dans des éléments plus grands et ces grands éléments dans d'encore plus grand éléments avant de faire afficher le contenu entier.<br>
				<br>
				Pour les affichages suivants, il est important de supprimer le contenu de la fenêtre et de vider les "tiroirs" avec une méthode dans la même classe qui sera appellée à chaque changement d'affichage majeur :<br><br>

			</p>
			<pre><code>
/**
 * Reset every content of the window
 * Must be called before every display which needs lot of changes
 */
private void resetWindow() {
    //TABLE
    if (userTableModel.getRowCount() > 0) {
        for (int i = userTableModel.getRowCount() - 1; i > -1; i--) {
            userTableModel.removeRow(i);
        }
    }
    if (architectTableModel.getRowCount() > 0) {
        for (int i = architectTableModel.getRowCount() - 1; i > -1; i--) {
            architectTableModel.removeRow(i);
        }
    }
    
    //MENUS AND MENULIST
    accessMenu.removeAll();
    accessMenu.revalidate();
    accessMenu.repaint();
    cho.removeAll();
    cho.revalidate();
    cho.repaint();
    
    //JTEXT AND JPASS
    userMailJTF.setText(null);
    passWord.setText(null);
    newMail.setText(null);
    confirmPass.setText(null);
    newPass.setText(null);
    
    //BOXES
    l1.removeAll();
    l1.revalidate();
    l1.repaint();
    l2.removeAll();
    l2.revalidate();
    l2.repaint();
    l3.removeAll();
    l3.revalidate();
    l3.repaint();
    l4.removeAll();
    l4.revalidate();
    l4.repaint();
    l5.removeAll();
    l5.revalidate();
    l5.repaint();
    c1.removeAll();
    c1.revalidate();
    c1.repaint();
    
    //PANEL AND WINDOW
    panel.removeAll();
    panel.revalidate();
    panel.repaint();
    window.getContentPane().removeAll();
    window.getContentPane().revalidate();
    window.getContentPane().repaint();
}
			</code></pre>

			<p>
				Cela dit, notre classe Display implémnte un actionLIsteners, afin de permettre à l'utilisateur d'utiliser les différents objets à sa disposition pour intéragir avec l'application. Dans le code d'affichage de la première fenêtre, cet ActionListener fut implémenté :<br><br>
			</p>
			<pre><code>
leave.addActionListener(new ActionListener() {
	@Override
	public void actionPerformed(ActionEvent e) {
	    window.dispose();
	}
});
			</code></pre>
			<p>
				Sur le premier écran donc, si l'utilisateur clique sur le bouton identifié "leave", le ActionListener va se déclencher et lancer le code à l'intérieur : ici ce sera <pre><code>window.dispose();</code></pre>
				qui sera executé, c'est à dire la fermeture de la fenêtre et donc la fin de l'éxécution de l'application.
			</p>
			<p>
				L'affichage ne pouvant se faire uniquement dans la classe "Display", il est impossible de modifier les éléments depuis une autre classe ou d'appeler celle-ci.<br>
				Cependant, l'appel de méthodes dans d'autre classes depuis les ActionsListeners présents sur les éléments affichés permet de lancer diverses méthodes de classes différentes afin de pouvoir récupérer des valeurs, comme la récupération d'un String contenant la syntaxe d'une requête SQL qui permettra de lancer cette même requête afin de faire afficher les informations liées à cette même requête.
			</p>
		</div>
	<div id=#maDoc>
	<h2>Documentation technique de la liaison JTable/BDD</h2>
	<p>Notre application permet de modifier directement la base de donnée à travers un tableau affichant ses informations</p>
	<div class="conteneurImgs">
		<img src="img/modifTable1.png">
		<img src="img/modifTable2.png">
		<img src="img/modifTable3.png">
	</div>
	<p>Pour ce faire, nous créons pour commencer notre JTable qui vont afficher les informations de la BDD, ici on veut gérer les utilisateurs en tant qu'admin</p>
	<div class = "conteneurCode">
	<pre><code>
		String[] entetes = {"id", "name", "firstname", "mail", "password", "role", "signdatetime"}; <span style="color:grey">//Ici, nous créons le nom des colonnes de notre tableau</span>
    		JTable table = new JTable(); <span style="color:grey">//On créer un objet de type JTable</span>
    		DefaultTableModel aModel = (DefaultTableModel) table.getModel(); <span style="color:grey">//Nous créons ensuite un modèle de tableau, c'est grâce à lui que nous allons le peupler</span>
    		aModel.setColumnIdentifiers(entetes); <span style="color:grey">//On lui attribue les entêtes crées</span>
    		JScrollPane jsp = new JScrollPane(table);
    		Dimension dimension = new Dimension(750, 300);
    		jsp.setPreferredSize(dimension);
    		window.add(jsp); <span style="color:grey">//On ajoute un conteneur scrollable d'une certaine dimension dans lequel on affichera le tableau</span>
	</code></pre>
	</div>
	<div class="conteneurCode">
	<pre><code>
		String request = requestText; <span style="color:grey">//On récupère la requête en paramêtre de la fonction, ici la requête va SELECT * la table users</span>
        		try {
            		Statement statement = connection.createStatement(); <span style="color:grey">//On se connecte à la base de donnée</span>
            		ResultSet results = statement.executeQuery(request); <span style="color:grey">//On exécute la requête et on stocke les données dans la variable results</span>
            		ResultSetMetaData meta = results.getMetaData(); <span style="color:grey">//Ici, on récupère et on stocke les méta données</span>
            		int colCount = meta.getColumnCount(); <span style="color:grey">//On stocke le nombre de colonnes dans une variable colCount</span>
            		while (results.next()) { <span style="color:grey">//Tant qu'on n'est pas à la fin des données</span>
                		Object[] objects = new Object[colCount];
                		for(int i = 0; i < colCount; i++) {
                    		objects[i] = results.getObject(i+1);
                		} <span style="color:grey">//On créer des nouveaux tableaux d'objets dans lesquels on stocke chaque ligne du tableau de la BDD</span>
                  aModel.addRow(objects); <span style="color:grey">//On ajoute les différentes ligne à notre modèle</span>
            	}
                 table.setModel(aModel); <span style="color:grey">//On peuple notre JTable grâce à ce modèle</span>
       			} catch (SQLException e) {
            		e.printStackTrace();
        		}
	</code></pre>
	</div>
	<p>Nous voulons récupérer les données de notre JTable qui changent et les envoyer à la BDD pour la modifier du même coup. Pour détecter si les données du JTable sont modifées, nous allons ajouter un listener sur son modèle comme suit :</p>
	<div class="conteneurCode">
		<pre><code>
			aModel.addTableModelListener(new TableModelListener() { <span style="color:grey">//On ajoute le listener au modèle</span><br>
            	@Override<br>
            	public void tableChanged(TableModelEvent tableModelEvent) { editableTable.editUsers(tableModelEvent, table, connection); } <span style="color:grey">//Chaque fois que le modèle change, les changements seront envoyés à la méthode editUsers de la classe editableTable</span><br>
        	});<br>
		</code></pre>
	</div>
	<p>Nous avons maintenant récupérer les modifications faites sur notre JTable, nous devons maintenant les transmettre à la BDD pour qu'elle se mette à jour à l'aide de la méthode editUsers pour la table "users"</p>
	<div class="conteneurCode">
		<pre><code>
			public void editUsers(TableModelEvent t, JTable table, Connection connection) {<br>
        		if (t.getType() == TableModelEvent.UPDATE) { <span style="color:grey">//Si le changement qui a eu lieu est de type "update" c'est à dire si on a modifié le modèle</span><br>
            		int row = t.getFirstRow();<br>
            		int column = t.getColumn(); <span style="color:grey">//On récupère les coordonnées du changement</span><br>
            		String newValue = (String)table.getValueAt(row, column); <span style="color:grey">//On récupère la nouvelle valeur</span><br>
            		Object id = table.getValueAt(row, 0); <span style="color:grey">//On récupère l'id de la ligne où le changement a eu lieu</span><br>
            		String request = "SELECT * FROM users WHERE user_id = "+id; <span style="color:grey">//On créer la requête pour récupérer les données de la ligne en question</span><br>
		</code></pre>
	</div>
	<div class="conteneurCode">
		<pre><code>
			try {<br>
                Statement statement = connection.createStatement(); <span style="color:grey">//On établit la connexion</span><br>
                ResultSet results = statement.executeQuery(request);<br>
                ResultSetMetaData rsmd = results.getMetaData(); <span style="color:grey">//On éxécute la requête créée précédemment et on la stocke</span><br>
                String columnToEdit = rsmd.getColumnName(column+1); <span style="color:grey">//On récupère la colonne à éditer</span><br>
                String update = "UPDATE users SET "+columnToEdit+" = '"+newValue+"' WHERE user_id = "+id; <span style="color:grey">//On créer la requête pour éditer la BDD</span><br>
                System.out.println(update);<br>
                statement.executeUpdate(update); <span style="color:grey">//On éxécute la requête d'édition</span><br>
            } catch (SQLException e) {<br>
                e.printStackTrace();<br>
            }<br>
		</code></pre>
	</div>
	<h3>Nous avons donc réussi à éditer la base de donnée en direct grâce à notre Jtable !</h3>
	<h2>Stockage des infos utilisateur (pseudo, password...) dans un fichier INI</h2>
	<p>Nous allons voir comment procéder à la récupération des informations de l'utilisateur courant et les stocker dans un fichier INI</p>
	<p>Lors d'une connexion, un bouton à cocher est présent à la droite du bouton de connexion. Coché par l'utilisateur, il permettra de préremplir automatiquement les champs de texte</p>
	<div class="conteneurImgs">
		<img src="img/Ini1.png">
		<img src="img/Ini2.png">
	</div>
	<p>Lors de la connexion de l'utilisateur, on vérifie s'il a coché la case "Remember my informations"</p>
	<p>S'il l'a fait et que la connexion a réussi, on procède à la création d'un fichier d'informations INI</p>
	<pre><code>
		 static void creation(JTextField mail, JTextField passWord, JCheckBox checkBox) {<br>
        try {<br>
            if (checkBox.isSelected()) { <span style="color:grey">//On vérifie que la case "Remember my informations"</span><br>
                File file = new File("infosCo.ini");<br>
                file.createNewFile(); <span style="color:grey">//Si c'est le cas, on créer le fichier "infosCo.ini"</span><br>
                Wini ini = new Wini(file); <span style="color:grey">//On utilise la bibliothèque ini4j pour manipuler le fichier .ini</span><br>
                ini.put("InfosCo", "mail", mail.getText());<br>
                ini.put("InfosCo", "password", passWord.getText());<br>
                ini.store(); <span style="color:grey">//On stocke les informations des champs de connexion dans le fichier, le mail dans la section "mail", le password dans la section "password"</span><br>
            }<br>
        } catch (IOException e) {<br>
            e.printStackTrace();<br>
        }<br>
    }<br>
	</code></pre>	
	<img src="img/Ini3.png">
	<p>Voici le fichier créer et les informations stockées dedans</p>
	<p>Nous voulons maintenant, lorsque l'écran d'accueil est chargé que les champs de texte soient préremplis avec les informations contenues dans le fichier Ini</p>
	<pre><code>
		public void check(JTextField user, JTextField passWord) {<br>
        	File file = new File("infosCo.ini");<br>
        	if (file.exists()) { <span style="color:grey">//On vérifie si le fichier Ini existe déjà</span><br>
            	try {<br>
                	Wini ini = new Wini(file);<br>
                	String stringMail = ini.get("InfosCo", "mail");<br>
                	String stringPassWord = ini.get("InfosCo", "password");  <span style="color:grey">//Si oui, on récupère les informations à la section "mail" et "password"</span><br>
                	user.setText(stringMail);<br>
                	passWord.setText(stringPassWord); <span style="color:grey">//Avec; on remplit les champs de texte du pseudo et du password pris en paramètre</span><br>
            	} catch (IOException e) {<br>
               		e.printStackTrace();<br>
            	}<br>
        	}<br>
    	}<br>
	</code></pre>
	<h3>Et voilà, nos champs de connexion sont désormais préremplis lors du chargement de la fenêtre !</h3>
	</div>
	</div>
	<!-- Footer / credits -  -->
	<footer>
		<div class="low-foot">
			<div><a href="">©2020 Tous droits réservés</a></div>
			<div><a href="contact.html">Contact</a></div>
		</div>
	</footer>

	<script>
		/* When the user clicks on the button, 
		toggle between hiding and showing the dropdown content */
		function myFunction(event) {
			event.stopPropagation();
			document.getElementById("myDropdown").classList.toggle("show");
		}

		// Close the dropdown if the user clicks outside of it
		window.onclick = function(event) {
			if (!event.target.matches('.dropbtn')) {
				var dropdowns = document.getElementsByClassName("dropdown-content");
				var i;
				for (i = 0; i < dropdowns.length; i++) {
					var openDropdown = dropdowns[i];
					if (openDropdown.classList.contains('show')) {
						openDropdown.classList.remove('show');
					}
				}
			}
		}

		function showHideNewUser(){
		    var div = document.getElementById("contentNewUser");
		    var customer = document.getElementById("contentCustomer");
		    var architect = document.getElementById("contentArchitect");
		    var admin = document.getElementById("contentAdmin");
		    if (div.className === "") {
		        customer.className = "";
		        architect.className = "";
		        admin.className = "";
		        div.className = "active";
		    } else {
		        div.className = "";
		    }
		}

		function showHideCustomer(){
		    var div = document.getElementById("contentCustomer");
		    var newUser = document.getElementById("contentNewUser");
		    var architect = document.getElementById("contentArchitect");
		    var admin = document.getElementById("contentAdmin");
		    if (div.className === "") {
		        newUser.className = "";
		        architect.className = "";
		        admin.className = "";
		        div.className = "active";
		    } else {
		        div.className = "";
		    }
		}

		function showHideArchitect(){
		    var div = document.getElementById("contentArchitect");
		    var newUser = document.getElementById("contentNewUser");
		    var customer = document.getElementById("contentCustomer");
		    var admin = document.getElementById("contentAdmin");
		    if (div.className === "") {
		        newUser.className = "";
		        customer.className = "";
		        admin.className = "";
		        div.className = "active";
		    } else {
		        div.className = "";
		    }
		}

		function showHideAdmin(){
		    var div = document.getElementById("contentAdmin");
		    var newUser = document.getElementById("contentNewUser");
		    var customer = document.getElementById("contentCustomer");
		    var architect = document.getElementById("contentArchitect");
		    if (div.className === "") {
		        newUser.className = "";
		        customer.className = "";
		        architect.className = "";
		    	div.className = "active";
		    } else {
		        div.className = "";
		    }
		}
	</script>
</body>